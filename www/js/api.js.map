{
  "version": 3,
  "sources": ["api.ts"],
  "sourcesContent": ["type UserEntry = {\n    ItemId: bigint\n    Status: string\n    ViewCount: number\n    UserRating: number\n    Notes: string\n    CurrentPosition: string\n    Extra: string\n}\n\n\ntype UserStatus = \"\" |\n\t\t\t\t \"Viewing\" |\n\t\t\t\t \"Finished\" |\n\t\t\t\t \"Dropped\" |\n\t\t\t\t \"Planned\" |\n\t\t\t\t \"ReViewing\" |\n\t\t\t\t \"Paused\"\n\ntype EntryType = \"Show\" |\n\t\t\t\t \"Movie\" |\n\t\t\t\t \"MovieShort\" |\n\t\t\t\t \"Game\" |\n\t\t\t\t \"BoardGame\" |\n\t\t\t\t \"Song\" |\n\t\t\t\t \"Book\" |\n\t\t\t\t \"Manga\" |\n\t\t\t\t \"Collection\" |\n\t\t\t\t \"Picture\" |\n\t\t\t\t \"Meme\" |\n\t\t\t\t \"Library\"\n\ntype UserEvent = {\n    ItemId: bigint\n    Event: string\n    Timestamp: number\n    After: number\n    TimeZone: string\n}\n\n\ntype InfoEntry = {\n    ItemId: bigint\n    Collection: string\n    Format: number\n    ArtStyle: number\n    Location: string\n    Native_Title: string\n    ParentId: bigint\n    PurchasePrice: number\n    Type: string\n    En_Title: string\n    CopyOf: bigint\n    Library: bigint\n\n    Tags: string[]\n}\n\n\ntype MetadataEntry = {\n    ItemId: bigint\n    Rating: number\n    RatingMax: number\n    Description: string\n    ReleaseYear: number\n    Thumbnail: string\n    MediaDependant: string\n    Datapoints: string\n    Title: string\n    Native_Title: string\n}\n\n\ntype IdentifyResult = {\n    Description: string\n    Thumbnail: string\n}\n\ntype Status = string\n\nlet formats: {[key: number]: string} = {}\n\nfunction canBegin(status: Status) {\n    return status === \"Finished\" || status === \"Dropped\" || status === \"Planned\" || status === \"\"\n}\n\nfunction canPause(status: Status) {\n    return status === \"Viewing\" || status === \"ReViewing\"\n}\n\nfunction canResume(status: Status) {\n    return status === \"Paused\"\n}\n\nasync function listFormats() {\n    if(Object.keys(formats).length > 0) return formats\n\n    const res = await fetch(`${apiPath}/type/format`)\n\n    if(res.status !== 200) {\n        return formats\n    }\n\n    const json = await res.json()\n    formats = json\n    return formats\n}\n\nfunction mkStrItemId(jsonl: string) {\n    return jsonl\n        .replace(/\"ItemId\":\\s*(\\d+),/, \"\\\"ItemId\\\": \\\"$1\\\",\")\n        .replace(/\"ParentId\":\\s*(\\d+),/, \"\\\"ParentId\\\": \\\"$1\\\",\")\n        .replace(/\"CopyOf\":\\s*(\\d+)(,)?/, \"\\\"CopyOf\\\": \\\"$1\\\"$2\")\n        .replace(/\"Library\":\\s*(\\d+)(,)?/, \"\\\"Library\\\": \\\"$1\\\"$2\")\n}\n\nfunction mkIntItemId(jsonl: string) {\n    return jsonl\n        .replace(/\"ItemId\":\"(\\d+)\",/, \"\\\"ItemId\\\": $1,\")\n        .replace(/\"ParentId\":\"(\\d+)\",/, \"\\\"ParentId\\\": $1,\")\n        .replace(/\"CopyOf\":\"(\\d+)\"(,)?/, \"\\\"CopyOf\\\": $1$2\")\n        .replace(/\"Library\":\"(\\d+)\"(,)?/, \"\\\"Library\\\": $1$2\")\n}\n\nfunction parseJsonL(jsonl: string) {\n    const bigIntProperties = [\"ItemId\", \"ParentId\", \"CopyOf\", \"Library\"]\n    try {\n        return JSON.parse(jsonl, (key, v) => bigIntProperties.includes(key) ? BigInt(v) : v)\n    }\n    catch (err) {\n        console.error(\"Could not parse json\", err)\n    }\n}\n\nasync function loadList<T>(endpoint: string): Promise<T[]> {\n    const res = await fetch(`${apiPath}/${endpoint}?uid=${uid}`)\n    if (!res) {\n        return []\n    }\n\n    const text = await res.text()\n    if (!text) {\n        return []\n    }\n\n    const lines = text.split(\"\\n\").filter(Boolean)\n    return lines\n        .map(mkStrItemId)\n        .map(parseJsonL)\n}\n\nasync function copyUserInfo(oldid: bigint, newid: bigint) {\n    return await fetch(`${apiPath}/engagement/copy?src-id=${oldid}&dest-id=${newid}`).catch(console.error)\n}\n\nfunction typeToSymbol(type: string) {\n    const conversion = {\n        \"Show\": \"\uD83D\uDCFA\uFE0E\",\n        \"Movie\": \"\uD83D\uDCFD\",\n        \"MovieShort\": \"\u23EF\",\n        \"Book\": \"\uD83D\uDCDA\uFE0E\",\n        \"Manga\": \"\u672C\",\n        \"Game\": \"\uD83C\uDFAE\uFE0E\",\n        \"Song\": \"\u266B\",\n        \"Collection\": \"\uD83D\uDDC4\",\n        \"BoardGame\": \"\uD83C\uDFB2\uFE0E\",\n        \"Picture\": \"\uD83D\uDDBC\",\n        \"Meme\": \"\uD83C\uDCCF\",\n        \"Unowned\": \"X\"\n    }\n    if (type in conversion) {\n        //@ts-ignore\n        return conversion[type]\n    }\n    return type\n}\n\nasync function nameToFormat(name: string): Promise<number> {\n    const DIGI_MOD = 0x1000\n    let val = 0\n    name = name.toLowerCase()\n    if (name.includes(\"+digital\")) {\n        name = name.replace(\"+digital\", \"\")\n        val |= DIGI_MOD\n    }\n\n    const formats = Object.fromEntries(Object.entries(await listFormats()).map(([k, v]) => [v, Number(k)]))\n\n    val |= formats[name as keyof typeof formats]\n    return val\n\n}\n\nasync function formatToName(format: number) {\n    const DIGI_MOD = 0x1000\n    let out = \"\"\n    if ((format & DIGI_MOD) === DIGI_MOD) {\n        format -= DIGI_MOD\n        out = \" +digital\"\n    }\n\n    const formats = await listFormats()\n\n    if (format >= Object.keys(formats).length) {\n        return `unknown${out}`\n    }\n    return `${formats[format].toUpperCase()}${out}`\n}\n\nasync function identify(title: string, provider: string) {\n    return await fetch(`${apiPath}/metadata/identify?title=${encodeURIComponent(title)}&provider=${provider}`)\n}\n\nasync function finalizeIdentify(identifiedId: string, provider: string, applyTo: bigint) {\n    identifiedId = encodeURIComponent(identifiedId)\n    provider = encodeURIComponent(provider)\n    return await fetch(`${apiPath}/metadata/finalize-identify?identified-id=${identifiedId}&provider=${provider}&apply-to=${applyTo}`)\n}\n\nasync function updateThumbnail(id: bigint, thumbnail: string) {\n    return await fetch(`${apiPath}/metadata/mod-entry?id=${id}&thumbnail=${encodeURIComponent(thumbnail)}`)\n}\n\nasync function setParent(id: bigint, parent: bigint) {\n    return await fetch(`${apiPath}/mod-entry?id=${id}&parent-id=${parent}`)\n}\n\nasync function doQuery3(searchString: string) {\n    const res = await fetch(`${apiPath}/query-v3?search=${encodeURIComponent(searchString)}&uid=${uid}`).catch(console.error)\n    if (!res) return []\n\n    let itemsText = await res.text()\n    if (res.status !== 200) {\n        alert(itemsText)\n        return []\n    }\n\n    try {\n        let jsonL = itemsText.split(\"\\n\")\n            .filter(Boolean)\n            .map(mkStrItemId)\n            .map(parseJsonL)\n        return jsonL\n    } catch (err) {\n        console.error(err)\n    }\n\n    return []\n}\n\nasync function setPos(id: bigint, pos: string) {\n    return fetch(`${apiPath}/engagement/mod-entry?id=${id}&current-position=${pos}`)\n}\n\nfunction sortEntries(entries: InfoEntry[], sortBy: string) {\n    if (sortBy != \"\") {\n        if (sortBy == \"rating\") {\n            entries = entries.sort((a, b) => {\n                let aUInfo = findUserEntryById(a.ItemId)\n                let bUInfo = findUserEntryById(b.ItemId)\n                if (!aUInfo || !bUInfo) return 0\n                return bUInfo?.UserRating - aUInfo?.UserRating\n            })\n        } else if (sortBy == \"cost\") {\n            entries = entries.sort((a, b) => {\n                return b.PurchasePrice - a.PurchasePrice\n            })\n        } else if (sortBy == \"general-rating\") {\n            entries = entries.sort((a, b) => {\n                let am = findMetadataById(a.ItemId)\n                let bm = findMetadataById(b.ItemId)\n                if (!bm || !am) return 0\n                return normalizeRating(bm.Rating, bm.RatingMax || 100) - normalizeRating(am.Rating, am.RatingMax || 100)\n            })\n        } else if (sortBy == \"rating-disparity\") {\n            entries = entries.sort((a, b) => {\n                let am = findMetadataById(a.ItemId)\n                let au = findUserEntryById(a.ItemId)\n                let bm = findMetadataById(b.ItemId)\n                let bu = findUserEntryById(b.ItemId)\n                if (!bm || !am) return 0\n                let bGeneral = normalizeRating(bm.Rating, bm.RatingMax || 100)\n                let aGeneral = normalizeRating(am.Rating, am.RatingMax || 100)\n\n                let aUser = Number(au?.UserRating)\n                let bUser = Number(bu?.UserRating)\n\n\n                return (aGeneral - aUser) - (bGeneral - bUser)\n            })\n        } else if (sortBy == \"release-year\") {\n            entries = entries.sort((a, b) => {\n                let am = findMetadataById(a.ItemId)\n                let bm = findMetadataById(b.ItemId)\n                return (bm?.ReleaseYear || 0) - (am?.ReleaseYear || 0)\n            })\n        }\n    }\n    return entries\n}\n\ntype NewEntryParams = {\n    timezone: string,\n    title: string,\n    type: EntryType,\n    format: number,\n    price?: number,\n    \"is-digital\"?: boolean,\n    \"is-anime\"?: boolean,\n    \"art-style\"?: number,\n    \"libraryId\"?: bigint,\n    \"copyOf\"?: bigint,\n    \"parentId\"?: bigint,\n    \"native-title\": string,\n    \"tags\": string,\n    \"location\": string,\n    \"get-metadata\": boolean,\n    \"metadata-provider\": string,\n    \"user-rating\": number,\n    \"user-status\": UserStatus,\n    \"user-view-count\": number,\n    \"user-notes\": string\n}\n\nasync function newEntry(params: NewEntryParams) {\n    let qs = \"\"\n    for(let p in params) {\n        let v = params[p as keyof NewEntryParams]\n        if(typeof v === 'bigint') {\n            v = String(v)\n        } else if(typeof v !== 'undefined') {\n            v = encodeURIComponent(v)\n        } else {\n            continue\n        }\n        qs += `${p}=${v}`\n    }\n    return await fetch(`${apiPath}/add-entry${qs}`)\n}\n\nasync function apiDeleteEvent(itemId: bigint, ts: number, after: number) {\n    return await fetch(`${apiPath}/engagement/delete-event?id=${itemId}&after=${after}&timestamp=${ts}`)\n}\n\nasync function apiRegisterEvent(itemId: bigint, name: string, ts: number, after: number) {\n    const tz = Intl.DateTimeFormat().resolvedOptions().timeZone\n    return await fetch(`${apiPath}/engagement/register-event?name=${encodeURIComponent(name)}&id=${itemId}&after=${after}&timestamp=${ts}&timezone=${encodeURIComponent(tz)}`)\n}\n\nasync function addEntryTags(itemId: bigint, tags: string[]) {\n    return await fetch(`${apiPath}/add-tags?tags=${encodeURIComponent(tags.join(\"\\x1F\"))}&id=${itemId}`)\n}\n\nasync function deleteEntryTags(itemId: bigint, tags: string[]) {\n    return await fetch(`${apiPath}/delete-tags?tags=${encodeURIComponent(tags.join(\"\\x1F\"))}&id=${itemId}`)\n}\n\nasync function deleteEntry(itemId: bigint) {\n    return await fetch(`${apiPath}/delete-entry?id=${itemId}`)\n}\n\nasync function overwriteMetadataEntry(itemId: bigint) {\n    return fetch(`${apiPath}/metadata/fetch?id=${itemId}`)\n}\n\nasync function updateInfoTitle(itemId: bigint, newTitle: string) {\n    return fetch(`${apiPath}/mod-entry?id=${itemId}&en-title=${newTitle}`)\n}\n"],
  "mappings": "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",
  "names": ["status", "res", "jsonl", "bigIntProperties", "key", "v", "err", "endpoint", "text", "oldid", "newid", "type", "conversion", "name", "val", "formats", "k", "format", "out", "title", "provider", "identifiedId", "applyTo", "id", "thumbnail", "parent", "searchString", "itemsText", "pos", "entries", "sortBy", "a", "b", "aUInfo", "bUInfo", "am", "bm", "au", "bu", "bGeneral", "aGeneral", "aUser", "bUser", "params", "qs", "p", "itemId", "ts", "after", "tz", "tags", "newTitle"]
}
