{
  "version": 3,
  "sources": ["graph.ts"],
  "sourcesContent": ["function getCtx2(id: string): CanvasRenderingContext2D {\n    const canv = document.getElementById(id) as HTMLCanvasElement\n    return canv.getContext(\"2d\") as CanvasRenderingContext2D\n}\n\nconst typeColors = {\n    \"Manga\": \"#e5c890\",\n    \"Show\": \"#f7c8e0\",\n    \"Movie\": \"#95bdff\",\n    \"MovieShort\": \"#b4e4ff\",\n    \"Song\": \"#dfffd8\",\n    \"Game\": \"#fed8b1\",\n    \"Book\": \"gainsboro\",\n    \"Collection\": \"#b4befe\"\n}\n\nconst ctx = getCtx2(\"by-year\")\nconst rbyCtx = getCtx2(\"rating-by-year\")\n\nconst groupBySelect = document.getElementById(\"group-by\") as HTMLSelectElement\nconst typeSelection = document.getElementById(\"chart-type\") as HTMLSelectElement\n\nconst groupByInput = document.getElementById(\"group-by-expr\") as HTMLInputElement\n\nfunction ChartManager(mkChart: (entries: InfoEntry[]) => Promise<any>) {\n    let chrt: any = null\n    return async function(entries: InfoEntry[]) {\n        if (chrt) {\n            chrt.destroy()\n        }\n        chrt = await mkChart(entries)\n    }\n}\n\nfunction mkPieChart(ctx: CanvasRenderingContext2D, labels: string[], data: number[], labelText: string, colors: string[] = []) {\n    let obj = {\n        type: 'pie',\n        data: {\n            labels: labels,\n            datasets: [{\n                label: labelText,\n                data: data,\n                borderWidth: 1,\n            }]\n        },\n        options: {\n            plugins: {\n                legend: {\n                    labels: {\n                        color: \"white\"\n                    }\n                },\n                title: {\n                    color: \"white\",\n                    display: true,\n                    text: labelText,\n                }\n            },\n            responsive: true\n        }\n    }\n    if (colors.length) {\n        //@ts-ignore\n        obj.data.datasets[0].backgroundColor = colors\n    }\n    //@ts-ignore\n    return new Chart(ctx, obj)\n}\n\nfunction mkBarChart(ctx: CanvasRenderingContext2D, x: any[], y: any[], labelText: string) {\n    //@ts-ignore\n    return new Chart(ctx, {\n        type: 'bar',\n        data: {\n            labels: x,\n            datasets: [{\n                label: labelText,\n                data: y,\n                borderWidth: 1,\n                backgroundColor: \"#95bdff\"\n            }]\n        },\n        options: {\n            plugins: {\n                legend: {\n                    labels: {\n                        color: \"white\"\n                    }\n                }\n            },\n            responsive: true,\n            scales: {\n                y: {\n                    grid: {\n                        color: \"grey\"\n                    },\n                    ticks: {\n                        color: \"white\"\n                    },\n                    beginAtZero: true\n                },\n                x: {\n                    grid: {\n                        color: \"grey\"\n                    },\n                    ticks: {\n                        color: \"white\"\n                    }\n                }\n            }\n        }\n    })\n}\n\nfunction mkXTypeChart(ctx: CanvasRenderingContext2D, x: any[], y: any[], labelText: string) {\n    const ty = typeSelection.value\n    if (ty === \"bar\") {\n        return mkBarChart(ctx, x, y, labelText)\n    } else {\n        let totalY = ty === \"pie-percentage\"\n            ? y.reduce((p, c) => p + c, 0)\n            : 0\n\n        //sort y values, keep x in same order as y\n        //this makes the pie chart look better\n\n        //put x, y into a dict so that a given x can be assigned to a given y easily\n        let dict: Record<any, any> = {}\n        for (let i = 0; i < y.length; i++) {\n            dict[x[i]] = ty === 'pie-percentage' ? y[i] / totalY * 100 : y[i]\n        }\n\n        //sort entries based on y value\n        const sorted = Object.entries(dict).sort(([_, a], [__, b]) => b - a)\n\n        //y is the 2nd item in the entry list\n        y = sorted.map(i => i[1])\n        //x is the 1st item in the entry list\n        x = sorted.map(i => i[0])\n\n        return mkPieChart(ctx, x, y, labelText)\n    }\n}\n\nfunction getWatchTime(watchCount: number, meta: MetadataEntry): number {\n    if (!meta.MediaDependant) {\n        return 0\n    }\n    let data\n    try{\n        data = JSON.parse(meta.MediaDependant)\n    }\n    catch(err){\n        console.error(\"Could not parse json\", meta.MediaDependant)\n        return 0\n    }\n    let length = 0\n    for (let type of [\"Show\", \"Movie\"]) {\n        if (!(`${type}-length` in data)) {\n            continue\n        }\n        length = Number(data[`${type}-length`])\n        break\n    }\n    if (isNaN(length)) {\n        return 0\n    }\n    return length * watchCount\n}\n\nfunction fillGap(obj: Record<any, any>, label: string) {\n    obj[label] = []\n    if (!((Number(label) + 1) in obj)) {\n        fillGap(obj, String(Number(label) + 1))\n    }\n}\n\nfunction organizeDataByExpr(entries: InfoEntry[]): Record<string, InfoEntry[]> {\n    let expr = groupByInput.value\n\n    let group: Record<string, InfoEntry[]> = Object.groupBy(entries, item => {\n        let meta = findMetadataById(item.ItemId)\n        let user = findUserEntryById(item.ItemId)\n        let symbols = makeSymbolsTableFromObj({ ...item, ...meta, ...user })\n\n        return parseExpression(expr, symbols).toStr().jsValue\n    }) as Record<string, InfoEntry[]>\n    //Sometimes there's just empty groups i'm not sure why\n    for (let key in group) {\n        if (group[key].length === 0) {\n            delete group[key]\n        }\n    }\n    return group\n}\n\nasync function organizeData(entries: InfoEntry[]): Promise<[string[], InfoEntry[][]]> {\n    let groupBy = groupBySelect.value\n\n    const groupings: Record<string, (i: InfoEntry) => any> = {\n        \"Year\": i => globalsNewUi.metadataEntries[String(i.ItemId)].ReleaseYear,\n        \"Decade\": i => {\n            const year = String(globalsNewUi.metadataEntries[String(i.ItemId)].ReleaseYear)\n            if (year == \"0\") {\n                return \"0\"\n            }\n            let century = year.slice(0, 2)\n            let decade = year.slice(2)[0]\n            return `${century}${decade}0s`\n        },\n        \"Century\": i => {\n            const year = String(globalsNewUi.metadataEntries[String(i.ItemId)].ReleaseYear)\n            if (year == \"0\") {\n                return \"0\"\n            }\n            let century = year.slice(0, 2)\n            return `${century}00s`\n        },\n        \"Type\": i => i.Type,\n        \"Format\": i => formats[i.Format] || \"N/A\",\n        \"Status\": i => globalsNewUi.userEntries[String(i.ItemId)].Status,\n        \"View-count\": i => globalsNewUi.userEntries[String(i.ItemId)].ViewCount,\n        \"Is-anime\": i => (i.ArtStyle & 1) == 1,\n        \"Item-name\": i => i.En_Title\n    }\n\n    let data: Record<string, InfoEntry[]>\n    if (groupBy === \"Tags\") {\n        data = {}\n        for (let item of entries) {\n            for (let tag of item.Tags) {\n                if (data[tag]) {\n                    data[tag].push(item)\n                } else {\n                    data[tag] = [item]\n                }\n            }\n        }\n    }\n    else if (groupByInput.value) {\n        data = organizeDataByExpr(entries)\n    }\n    else {\n        data = Object.groupBy(entries, (groupings[/**@type {keyof typeof groupings}*/(groupBy)])) as Record<string, InfoEntry[]>\n    }\n\n\n    let sortBy = document.getElementsByName(\"sort-by\")[0] as HTMLInputElement\n\n    //filling in years messes up the sorting, idk why\n    if (sortBy.value == \"\") {\n        //this is the cutoff year because this is when jaws came out and changed how movies were produced\n        const cutoffYear = 1975\n        if (groupBy === \"Year\") {\n            let highestYear = +Object.keys(data).sort((a, b) => +b - +a)[0]\n            for (let year in data) {\n                let yearInt = +year\n                if (highestYear === yearInt) break\n                if (yearInt < cutoffYear) continue\n                if (!((yearInt + 1) in data)) {\n                    fillGap(data, String(yearInt + 1))\n                }\n            }\n        }\n    }\n\n    let x = Object.keys(data)\n    let y = Object.values(data)\n    if (sortBy.value == \"rating\") {\n        let sorted = Object.entries(data).sort((a, b) => {\n            let aRating = a[1].reduce((p, c) => {\n                let user = findUserEntryById(c.ItemId)\n                return p + (user?.UserRating || 0)\n            }, 0)\n            let bRating = b[1].reduce((p, c) => {\n                let user = findUserEntryById(c.ItemId)\n                return p + (user?.UserRating || 0)\n            }, 0)\n\n            return bRating / b[1].length - aRating / a[1].length\n        })\n        x = sorted.map(v => v[0])\n        y = sorted.map(v => v[1])\n    } else if (sortBy.value === \"cost\") {\n        let sorted = Object.entries(data).sort((a, b) => {\n            let aCost = a[1].reduce((p, c) => {\n                return p + (c?.PurchasePrice || 0)\n            }, 0)\n            let bCost = b[1].reduce((p, c) => {\n                return p + (c?.PurchasePrice || 0)\n            }, 0)\n\n            return bCost - aCost\n        })\n        x = sorted.map(v => v[0])\n        y = sorted.map(v => v[1])\n    }\n    return [x, y]\n}\n\nfunction sortXY(x: string[], y: any[]) {\n    let associated: Record<string, any> = {}\n    for (let i = 0; i < x.length; i++) {\n        associated[x[i]] = y[i]\n    }\n\n    let associatedList = Object.entries(associated).sort(([_, a], [__, b]) => b - a)\n    x = associatedList.map(x => x[0])\n    y = associatedList.map(x => x[1])\n    return [x, y]\n}\n\nconst watchTimeByYear = ChartManager(async (entries) => {\n    let [years, data] = await organizeData(entries)\n\n    let watchTimes = data\n        .map(v => {\n            return v.map(i => {\n                let watchCount = globalsNewUi.userEntries[String(i.ItemId)].ViewCount\n                let thisMeta = globalsNewUi.metadataEntries[String(i.ItemId)]\n                let watchTime = getWatchTime(watchCount, thisMeta)\n                return watchTime / 60\n            }).reduce((p, c) => p + c, 0)\n        });\n\n    return mkXTypeChart(getCtx2(\"watch-time-by-year\"), years, watchTimes, \"Watch time\")\n})\n\nconst adjRatingByYear = ChartManager(async (entries) => {\n    let [years, data] = await organizeData(entries)\n\n    let items = data\n    let totalItems = 0\n    let totalRating = 0\n    for (let item of items) {\n        totalItems += item.length\n        totalRating += item.reduce((p, c) => p + globalsNewUi.userEntries[String(c.ItemId)].UserRating, 0)\n    }\n    let avgItems = totalItems / items.length\n    let generalAvgRating = totalRating / totalItems\n    const ratings = data\n        .map(v => {\n            let ratings = v.map(i => {\n                let thisUser = globalsNewUi.userEntries[String(i.ItemId)]\n                return thisUser.UserRating\n            })\n            let totalRating = ratings\n                .reduce((p, c) => (p + c), 0)\n\n            let avgRating = totalRating / v.length\n            // let min = Math.min(...ratings)\n\n            return (avgRating - generalAvgRating) + (v.length - avgItems)\n\n            // return (avgRating + v.length / (Math.log10(avgItems) / avgItems)) + min\n        })\n\n    return mkXTypeChart(getCtx2(\"adj-rating-by-year\"), years, ratings, 'adj ratings')\n})\n\nconst costByFormat = ChartManager(async (entries) => {\n    entries = entries.filter(v => v.PurchasePrice > 0)\n    let [labels, data] = await organizeData(entries)\n    let totals = data.map(v => v.reduce((p, c) => p + c.PurchasePrice, 0))\n\n    return mkXTypeChart(getCtx2(\"cost-by-format\"), labels, totals, \"Cost by\")\n})\n\nconst ratingByYear = ChartManager(async (entries) => {\n    let [years, data] = await organizeData(entries)\n    const ratings = data\n        .map(v => v\n            .map(i => {\n                let thisUser = globalsNewUi.userEntries[String(i.ItemId)]\n                return thisUser.UserRating\n            })\n            .reduce((p, c, i) => (p * i + c) / (i + 1), 0)\n        )\n\n    return mkXTypeChart(rbyCtx, years, ratings, 'ratings')\n})\n\nconst generalRating = ChartManager(async (entries) => {\n    let [years, data] = await organizeData(entries)\n    const ratings = data.map(v => {\n        return v.map(i => {\n            let meta = findMetadataById(i.ItemId)\n            let rating = meta?.Rating\n            let max = meta?.RatingMax\n            if (rating && max) {\n                return (rating / max) * 100\n            }\n            return 0\n        }).reduce((p, c, i) => (p * i + c) / (i + 1), 0)\n    })\n    return mkXTypeChart(getCtx2(\"general-rating-by-year\"), years, ratings, \"general ratings\")\n})\n\nconst ratingDisparityGraph = ChartManager(async (entries) => {\n    let [years, data] = await organizeData(entries)\n    const disparity = data.map(v => {\n        return v.map(i => {\n            let meta = findMetadataById(i.ItemId)\n            let user = findUserEntryById(i.ItemId)\n            let rating = meta?.Rating\n            let max = meta?.RatingMax\n            if (rating && max) {\n                let general = (rating / max) * 100\n                return (user?.UserRating || 0) - general\n            }\n            return user?.UserRating || 0\n        }).reduce((p, c) => p + c, 0)\n    })\n    return mkXTypeChart(getCtx2(\"rating-disparity-graph\"), years, disparity, \"Rating disparity\")\n})\n\nconst byc = ChartManager(async (entries) => {\n    let [years, data] = await organizeData(entries)\n    const counts = data.map(v => v.length)\n\n    return mkXTypeChart(ctx, years, counts, '#items')\n})\n\nfunction makeGraphs(entries: InfoEntry[]) {\n    byc(entries)\n    ratingByYear(entries)\n    adjRatingByYear(entries)\n    costByFormat(entries)\n    watchTimeByYear(entries)\n    generalRating(entries)\n    ratingDisparityGraph(entries)\n}\n\ngroupByInput.onchange = function() {\n    makeGraphs(globalsNewUi.selectedEntries)\n}\n\ngroupBySelect.onchange = typeSelection.onchange = function() {\n    makeGraphs(globalsNewUi.selectedEntries)\n}\n\nconst modeGraphView: DisplayMode = {\n    add(entry, updateStats = true) {\n        updateStats && changeResultStatsWithItem(entry)\n        makeGraphs(globalsNewUi.selectedEntries)\n    },\n\n    sub(entry, updateStats = true) {\n        updateStats && changeResultStatsWithItem(entry, -1)\n        makeGraphs(globalsNewUi.selectedEntries)\n    },\n\n    addList(entries, updateStats = true) {\n        updateStats && changeResultStatsWithItemList(entries)\n        makeGraphs(globalsNewUi.selectedEntries)\n    },\n\n    subList(entries, updateStats = true) {\n        updateStats && changeResultStatsWithItemList(entries, -1)\n    }\n}\n"],
  "mappings": "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",
  "names": ["id", "mkChart", "chrt", "entries", "ctx", "labels", "data", "labelText", "colors", "obj", "x", "y", "ty", "totalY", "p", "c", "dict", "i", "sorted", "_", "a", "__", "b", "watchCount", "meta", "length", "type", "label", "expr", "group", "item", "user", "symbols", "key", "groupBy", "groupings", "year", "century", "decade", "tag", "sortBy", "highestYear", "yearInt", "aRating", "v", "aCost", "associated", "associatedList", "years", "watchTimes", "thisMeta", "items", "totalItems", "totalRating", "avgItems", "generalAvgRating", "ratings", "totals", "rating", "max", "disparity", "general", "counts", "entry", "updateStats"]
}
