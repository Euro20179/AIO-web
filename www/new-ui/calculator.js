const TT={Num:"NUM",Word:"WORD",String:"STRING",Add:"+",Sub:"-",Mul:"*",Div:"/",Lparen:"(",Rparen:")",Comma:",",Semi:";",Eq:"=",Gt:">",Lt:"<",Le:"<=",Ge:">=",DEq:"=="},keywords=["var"];class Token{constructor(e,t){this.ty=e,this.value=t}}class NodePar{constructor(e=null){this.children=[],e&&this.children.push(e)}addChild(e){this.children.push(e)}}class NumNode extends NodePar{constructor(e){super(),this.value=e}}class WordNode extends NodePar{constructor(e){super(),this.value=e}}class StringNode extends NodePar{constructor(e){super(),this.value=e}}class ErrorNode extends NodePar{constructor(e){super(),this.value=e}}class RUnOpNode extends NodePar{constructor(e,t){super(),this.left=e,this.operator=t}}class LUnOpNode extends NodePar{constructor(e,t){super(),this.right=e,this.operator=t}}class BinOpNode extends NodePar{constructor(e,t,r){super(),this.left=e,this.operator=t,this.right=r}}class VarDefNode extends NodePar{constructor(e,t){super(),this.name=e,this.expr=t}}class FuncDefNode extends NodePar{constructor(e,t){super(),this.name=e,this.program=t,this.closure=new SymbolTable}}class CallNode extends NodePar{constructor(e,t){super(),this.callabale=e,this.inner=t}}class ExprNode extends NodePar{constructor(e){super(),this.value=e}}class ProgramNode extends NodePar{}function parseExpression(s,e){const t=lex(s),n=new Parser(t).ast();return new Interpreter(n,e).interpret()}function buildNumber(s,e){let t=s[e];for(;"0123456789".includes(s[++e]);)t+=s[e];return[t,e]}function buildWord(s,e){let t=s[e];for(;s[++e]?.match(/[a-zA-Z0-9_]/);)t+=s[e];return[t,e]}function buildString(s,e){let t=s[e],r=!1;for(let n=e+1;n<s.length;n++){let o=s[n];if(o==="\\"){r=!0;continue}if(r)switch(o){case"n":o=`
`;break;case"t":o="	";break;case"\\":o="\\";break;default:o="\\"+o}else if(o==='"')break;t+=o}return[t,e+t.length+1]}function lex(s){let e=0,t=[];for(;e<s.length;){let r=s[e];if("0123456789".includes(r)){let[n,o]=buildNumber(s,e);t.push(new Token("Num",n)),e=o}else if(r.match(/[a-zA-Z_]/)){let[n,o]=buildWord(s,e);t.push(new Token("Word",n)),e=o}else if(r.trim())if(r==='"'){e++;let[n,o]=buildString(s,e);e=o,t.push(new Token("String",n))}else if(r==="=")e++,s[e]==="="?(e++,t.push(new Token("DEq","=="))):t.push(new Token("Eq","="));else if(r==="<")e++,s[e]==="<="?(e++,t.push(new Token("Le","<="))):t.push(new Token("Lt","<"));else if(r===">")e++,s[e]===">="?(e++,t.push(new Token("Ge",">="))):t.push(new Token("Gt",">"));else{let n=!1,o;for(o in TT)if(r===TT[o]){t.push(new Token(o,r)),e++,n=!0;break}n||(console.error(`Invalid token: ${r}`),e++)}else{e++;continue}}return t}class Parser{constructor(e){this.i=0,this.tokens=e}next(){return this.i++,this.i<this.tokens.length}back(){this.i--}curTok(){return this.tokens[this.i]}atom(){let e=this.curTok();if(!e)return new ErrorNode("Ran out of tokens");if(this.next(),e.ty==="Num")return new NumNode(Number(e.value));if(e.ty==="String")return new StringNode(e.value);if(e.ty==="Lparen"){let t=this.ast_expr();return this.curTok()?.ty!=="Rparen"?new ErrorNode("Missing matching ')'"):(this.next(),t)}else if(e.ty==="Word")return new WordNode(e.value);return new ErrorNode(`Invalid token: (${e.ty} ${e.value})`)}l_unop(){let e=this.curTok();if("+-".includes(e.value)){this.next();let t=this.atom();return new LUnOpNode(t,e)}return this.atom()}r_unop(){let e=this.l_unop(),t=this.curTok();return t&&t.ty=="Lparen"?this.funcCall(e):e}binop(e,t){let r=t.bind(this)(),n=this.curTok();for(;n&&e.includes(n.value);){this.next();let o=t.bind(this)();r=new BinOpNode(r,n,o),n=this.curTok()}return r}factor(){return this.binop("*/",this.r_unop)}term(){return this.binop("+-",this.factor)}comparison(){let e=this.term(),t=this.curTok();for(;t&&["<",">","<=",">=","=="].includes(t.value);){this.next();let r=this.comparison();e=new BinOpNode(e,t,r),t=this.curTok()}return e}funcCall(e){if(this.next(),this.curTok().ty==="Rparen")return this.next(),new CallNode(e,[]);let t=[this.ast_expr()];for(;this.curTok()?.ty==="Comma";)this.next(),t.push(this.ast_expr());let r=new CallNode(e,t);return this.curTok()?.ty!=="Rparen"?(console.error(`Invalid token: ${this.curTok().ty}, expected ")"`),new NumNode(0)):(this.next(),r)}varDef(){if(this.next(),this.curTok().ty==="Lparen")return this.funcDef();let e=this.curTok();return this.next(),this.curTok()?.ty!=="Eq"?(console.error("Expected '='"),new NumNode(0)):(this.next(),new VarDefNode(e,this.ast_expr()))}funcDef(){this.next(),this.next();let e=this.curTok();if(this.next(),this.curTok()?.ty!=="Eq")return console.error("Expected '='"),new NumNode(0);this.next();let t=this.program();return this.curTok().ty!=="Word"||this.curTok().value!=="rav"?(console.error("Expected 'rav'"),new NumNode(0)):(this.next(),new FuncDefNode(e,t))}ast_expr(){let e=this.curTok();return e.ty==="Word"&&e.value==="var"?this.varDef():new ExprNode(this.comparison())}program(){let e=new ProgramNode;for(e.addChild(this.ast_expr());this.curTok()?.ty==="Semi";)this.next(),e.addChild(this.ast_expr());return e}ast(){let e=new NodePar,t=this.program();return e.addChild(t),t}}class Type{constructor(e){this.jsValue=e}jsStr(){return String(this.jsValue)}toStr(){return new Str(this.jsStr())}toNum(){return new Num(Number(this.jsValue))}add(e){return console.error(`Unable to add ${this.constructor.name} and ${e.constructor.name}`),e}sub(e){return console.error(`Unable to add ${this.constructor.name} and ${e.constructor.name}`),e}mul(e){return console.error(`Unable to add ${this.constructor.name} and ${e.constructor.name}`),e}div(e){return console.error(`Unable to add ${this.constructor.name} and ${e.constructor.name}`),e}lt(e){return console.error(`Unable to compare ${this.constructor.name} < ${e.constructor.name}`),new Num(0)}gt(e){return console.error(`Unable to compare ${this.constructor.name} > ${e.constructor.name}`),new Num(0)}eq(e){return console.error(`Unable to compare ${this.constructor.name} == ${e.constructor.name}`),new Num(0)}call(e){return console.error(`Cannot call ${this.constructor.name}`),new Num(0)}}class Func extends Type{constructor(e){super(e)}call(e){return this.jsValue(...e)}}class Num extends Type{add(e){return new Num(this.jsValue+e.toNum().jsValue)}sub(e){return new Num(this.jsValue-e.toNum().jsValue)}mul(e){return new Num(this.jsValue*e.toNum().jsValue)}div(e){return new Num(this.jsValue/e.toNum().jsValue)}lt(e){return this.jsValue<Number(e.jsValue)?new Num(1):new Num(0)}gt(e){return new Num(+(this.jsValue>Number(e.jsValue)))}eq(e){return new Num(+(this.jsValue===e.toNum().jsValue))}toNum(){return this}}class Str extends Type{add(e){return this.jsValue+=String(e.jsValue),this}sub(e){return this.jsValue=this.jsValue.replaceAll(String(e.jsValue),""),this}mul(e){return this.jsValue=this.jsValue.repeat(Number(e.jsValue)),this}eq(e){return new Num(+(this.jsValue===e.toStr().jsValue))}}class List extends Type{jsStr(){let e="";for(let t of this.jsValue)e+=t.jsStr()+",";return e.slice(0,-1)}eq(e){if(!(e instanceof List))return new Num(0);let t=new Set(this.jsValue),r=new Set(e.jsValue);return t.difference(r).size===0?new Num(1):new Num(0)}}class SymbolTable{constructor(){this.symbols=new Map,this.setupDefaultFunctions()}setupDefaultFunctions(){this.symbols.set("abs",new Func(e=>new Num(Math.abs(e.toNum().jsValue)))),this.symbols.set("len",new Func(e=>e instanceof Str?new Num(e.jsValue.length):new Num(0))),this.symbols.set("str",new Func(e=>e.toStr())),this.symbols.set("round",new Func(e=>e instanceof Num?new Num(Math.round(e.jsValue)):new Num(0))),this.symbols.set("floor",new Func(e=>e instanceof Num?new Num(Math.floor(e.jsValue)):new Num(0))),this.symbols.set("max",new Func((...e)=>{let t=e[0].toNum();for(let r of e)r.toNum().jsValue>t.jsValue&&(t=r);return t})),this.symbols.set("min",new Func((...e)=>{let t=e[0].toNum();for(let r of e)r.toNum().jsValue<t.jsValue&&(t=r);return t}))}set(e,t){this.symbols.set(e,t)}get(e){return this.symbols.get(e)}copy(){let e=new SymbolTable;for(let t of this.symbols.entries())e.set(t[0],t[1]);return e}}class Interpreter{constructor(e,t){this.tree=e,this.symbolTable=t}NumNode(e){return new Num(e.value)}StringNode(e){return new Str(e.value)}WordNode(e){return this.symbolTable.get(e.value)?this.symbolTable.get(e.value):new Str(e.value)}LUnOpNode(e){let t=this.interpretNode(e.right);return e.operator.ty==="Add"?t:t.mul(new Num(-1))}BinOpNode(e){let t=this.interpretNode(e.left),r=this.interpretNode(e.right);return e.operator.ty==="Add"?t.add(r):e.operator.ty==="Sub"?t.sub(r):e.operator.ty==="Mul"?t.mul(r):e.operator.ty==="Div"?t.div(r):e.operator.ty==="DEq"?t.eq(r):e.operator.ty==="Lt"?t.lt(r):e.operator.ty==="Gt"?t.gt(r):e.operator.ty==="Ge"?t.gt(r)||t.eq(r)?new Num(1):new Num(0):e.operator.ty==="Le"?t.lt(r)||t.eq(r)?new Num(1):new Num(0):r}interpretNode(e){return this[e.constructor.name](e)}ErrorNode(e){return console.error(e.value),new Str(e.value)}CallNode(e){let t=e.inner.map(this.interpretNode.bind(this));return this.interpretNode(e.callabale).call(t)}VarDefNode(e){let t=this.interpretNode(e.expr);return this.symbolTable.set(e.name.value,t),t}FuncDefNode(e){return e.closure=this.symbolTable.copy(),this.symbolTable.set(e.name.value,new Func((...t)=>{for(let n=0;n<t.length;n++)e.closure.set(`arg${n}`,t[n]);return new Interpreter(e.program,e.closure).interpretNode(e.program)})),this.symbolTable.get(e.name.value)}ExprNode(e){return this.interpretNode(e.value)}ProgramNode(e){let t=[];for(let r of e.children)r.constructor.name in this?t.push(this.interpretNode(r)):console.error(`Unimplmemented: ${r.constructor.name}`);return t.slice(-1)[0]}interpret(){return this.interpretNode(this.tree)}}function jsVal2CalcVal(s){switch(typeof s){case"string":return new Str(s);case"number":return new Num(s);case"boolean":return new Num(Number(s));case"bigint":return new Num(Number(s));case"function":return new Func(function(){return jsVal2CalcVal(s(...arguments))});default:return new Num(NaN)}}function makeSymbolsTableFromObj(s){let e=new SymbolTable;for(let t in s){let r=s[t],n=jsVal2CalcVal(r);e.get(t)&&(t=`${t}2`),e.set(t,n)}return e}
