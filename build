#!/bin/bash

devmode=0
while getopts "d" OPT; do
    case "$OPT" in 
        d) devmode=1;;
    esac
done

[ "$devmode" = 1 ] && {
    esbuildOpts=--sourcemap
}

#create config.ts from ini {{{
AIO_CONFIGTS=./www/config.ts

handle_configts_from_ini() {
    section=""
    while read -r line; do
        case "$line" in
            \[*\])
                name="${line#'['}"
                name="${name%']'}"
                section="$name"
                ;;
            '') continue ;;
            *)
                ! [ "$section" = aio_limas ] && continue;

                name="${line%%[[:space:]]=*}"
                value="${line#*=[[:space:]]}"
                case "$name" in
                    host) host="$value" ;;
                    api) api="$value" ;;
                esac
        esac
    done < ./server-config.ini

    cat <<-EOF > "$AIO_CONFIGTS"
//making this not a constant so that a tampermonkey script can change it because i want to change it with a tampermonkey script
let AIO = "${host:-http://localhost:8080}"
const API = "${api:-/api/v1}"
EOF
}

handle_configts_from_ini

#}}}

# Generate JS API documentation
generate_js_api_docs() {
    local js_api_file="./www/ui/js_api.ts"
    local docs_file="./www/usage/js_api_docs.html"
    
    # Create temporary file for processing
    local temp_file=$(mktemp)
    
    # Extract function documentation using awk
    awk '
    # Initialize variables
    BEGIN {
        # State tracking
        in_doc = 0
        current_section = ""
        
        # Documentation parts
        func_name = ""
        doc_text = ""
        param_text = ""
        return_text = ""
    }
    
    # Start of JSDoc comment
    /^\/\*\*/ {
        in_doc = 1
        func_name = ""
        doc_text = ""
        param_text = ""
        return_text = ""
        next
    }
    
    # End of JSDoc comment
    in_doc && /^\s*\*\// {
        in_doc = 0
        next
    }
    
    # Process JSDoc content
    in_doc {
        # Remove leading * and spaces
        sub(/^\s*\* ?/, "", $0)
        
        # Handle @param tag
        if ($0 ~ /^@param/) {
            # Try to match with type first
            match($0, /@param\s+{([^}]+)}\s+([^\s]+)\s+-\s+(.+)/, arr)
            if (arr[1] != "") {
                param_text = param_text "<span class=\"parameter-item\">"
                param_text = param_text "<span class=\"parameter-name\"><code>" arr[2] "</code></span>"
                param_text = param_text "<span class=\"parameter-type\">(" arr[1] ")</span>"
                param_text = param_text "<span class=\"parameter-description\">" arr[3] "</span>"
                param_text = param_text "</span>"
            } else {
                # Try to match without type
                match($0, /@param\s+([^\s]+)\s+-\s+(.+)/, arr)
                if (arr[1] != "") {
                    param_text = param_text "<span class=\"parameter-item\">"
                    param_text = param_text "<span class=\"parameter-name\"><code>" arr[1] "</code></span>"
                    param_text = param_text "<span class=\"parameter-description\">" arr[2] "</span>"
                    param_text = param_text "</span>"
                }
            }
            next
        }
        
        # Handle @returns tag
        if ($0 ~ /^@returns/) {
            match($0, /@returns\s+(.+)/, arr)
            if (arr[1] != "") {
                return_text = arr[1]
            }
            next
        }
        
        # Collect main documentation text
        doc_text = doc_text $0 "<BR>"
    }
    
    # Process function declaration
    !in_doc && /^(async\s+)?function/ {
        match($0, /function\s+([a-zA-Z0-9_]+)/, arr)
        if (arr[1] != "") {
            func_name = arr[1]
            
            # Determine section based on function prefix
            if (func_name ~ /^ui_/) {
                if (current_section != "UI Functions") {
                    if (current_section != "") {
                        print "</ul>"
                    }
                    current_section = "UI Functions"
                    print "<h3>UI Functions</h3>"
                    print "<ul>"
                }
            } else if (func_name ~ /^aio_/) {
                if (current_section != "API Functions") {
                    if (current_section != "") {
                        print "</ul>"
                    }
                    current_section = "API Functions"
                    print "<h3>API Functions</h3>"
                    print "<ul>"
                }
            } else if (func_name ~ /^ua_/) {
                if (current_section != "User Agent Functions") {
                    if (current_section != "") {
                        print "</ul>"
                    }
                    current_section = "User Agent Functions"
                    print "<h3>User Agent Functions</h3>"
                    print "<ul>"
                }
            }
            
            # Print function documentation
            print "<article class=\"doc-card\">"
            print "<p class=\"function-name\"><code>" func_name "</code></p>"
            if (doc_text != "") {
                print "<p class=\"function-description\">" doc_text "</p>"
            }
            
            # Print parameters if any
            if (param_text != "") {
                print "<section class=\"parameters\">"
                print "<h4>Parameters</h4>"
                print "<span class=\"parameter-list\">" param_text "</span>"
                print "</section>"
            }
            
            # Print return type if any
            if (return_text != "") {
                print "<section class=\"return\">"
                print "<h4>Returns</h4>"
                print "<span class=\"return-type\">" return_text "</span>"
                print "</section>"
            }
            
            print "</article>"
        }
    }
    
    # Print footer
    END {
        print "</ul>"
    }
    ' "$js_api_file" | sed -e "/{{CONTENT}}/r /dev/stdin" -e "/{{CONTENT}}/d" "$(dirname "$0")/js_api_docs_template.html" > "$temp_file"
    
    # Move the processed file to the final location
    mv "$temp_file" "$docs_file"
}

generate_js_api_docs

#esbuild/typescript stuff
esbuild $(find . -regex '.*\.ts$') --minify --outdir=www $esbuildOpts

#compile html into one BIG html to avoid having to have all of this in one massive file while working on it. It gets really annoying lol
idx="./www/ui/index.html"
#copy the initial template file to the final output
cp "./www/ui/index-template.html" "$idx"
#for each template
for file in ./www/ui/html-templates/*.html; do
    name="${file##*/}"
    name="${name%.html}"
    #create a template html tag and put it into the final output html file
    cat <<EOTEMPLATE >> "$idx"
<template id="${name}">
$(cat "$file")
</template>

EOTEMPLATE
done

#main go program
${GO:-go} build .

